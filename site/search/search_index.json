{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python Janus Client","text":"<p>Easily send and share WebRTC media through Janus WebRTC server.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Supports HTTP/s and WebSockets communication with Janus.</li> <li>Support Admin/Monitor API:<ul> <li>Generic requests</li> <li>Configuration related requests</li> <li>Token related requests</li> </ul> </li> <li>Supports Janus plugin:<ul> <li>EchoTest Plugin</li> <li>VideoCall Plugin</li> <li>VideoRoom Plugin</li> </ul> </li> <li>Extendable Transport class and Plugin class</li> </ul>"},{"location":"#library-installation","title":"Library Installation","text":"<pre><code>pip install janus-client\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#simple-connect-and-disconnect","title":"Simple Connect And Disconnect","text":"<pre><code>import asyncio\nfrom janus_client import JanusSession, JanusEchoTestPlugin, JanusVideoRoomPlugin\n\n# Protocol will be derived from base_url\nbase_url = \"wss://janusmy.josephgetmyip.com/janusbasews/janus\"\n# OR\nbase_url = \"https://janusmy.josephgetmyip.com/janusbase/janus\"\n\nsession = JanusSession(base_url=base_url)\n\nplugin_handle = JanusEchoTestPlugin()\n\n# Attach to Janus session\nawait plugin_handle.attach(session=session)\n\n# Destroy plugin handle\nawait plugin_handle.destroy()\n</code></pre> <p>This will create a plugin handle and then destroy it.</p> <p>Notice that we don't need to call connect or disconnect explicitly. It's managed internally.</p>"},{"location":"#make-video-calls","title":"Make Video Calls","text":"<pre><code>import asyncio\nfrom janus_client import JanusSession, JanusVideoCallPlugin\nfrom aiortc.contrib.media import MediaPlayer, MediaRecorder\n\nasync def main():\n    # Create session\n    session = JanusSession(\n        base_url=\"wss://janusmy.josephgetmyip.com/janusbasews/janus\",\n    )\n\n    # Create plugin\n    plugin_handle = JanusVideoCallPlugin()\n\n    # Attach to Janus session\n    await plugin_handle.attach(session=session)\n\n    # Prepare username and media stream\n    username = \"testusernamein\"\n    username_out = \"testusernameout\"\n\n    player = MediaPlayer(\n        \"desktop\",\n        format=\"gdigrab\",\n        options={\n            \"video_size\": \"640x480\",\n            \"framerate\": \"30\",\n            \"offset_x\": \"20\",\n            \"offset_y\": \"30\",\n        },\n    )\n    recorder = MediaRecorder(\"./videocall_record_out.mp4\")\n\n    # Register myself as testusernameout\n    result = await plugin_handle.register(username=username_out)\n\n    # Call testusernamein\n    result = await plugin_handle.call(\n        username=username, player=player, recorder=recorder\n    )\n\n    # Wait awhile then hangup\n    await asyncio.sleep(30)\n\n    result = await plugin_handle.hangup()\n\n    # Destroy plugin\n    await plugin_handle.destroy()\n\n    # Destroy session\n    await session.destroy()\n\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        pass\n</code></pre> <p>This example will register to the VideoCall plugin using username <code>testusernameout</code>. It will then call the user registered using the username <code>testusernamein</code>.</p> <p>A portion of the screen will be captured and sent in the call media stream. The incoming media stream will be saved into <code>videocall_record_out.mp4</code> file.</p>"},{"location":"plugins/","title":"Plugins","text":"<p>Janus plugins provide specific functionality for different use cases. This library includes support for several core Janus plugins.</p> <p>Plugins are the core components that implement specific WebRTC functionality. Each plugin corresponds to a server-side Janus plugin and provides a Python interface for interacting with it.</p>"},{"location":"plugins/#base-plugin-class","title":"Base Plugin Class","text":"<p>All plugins inherit from the base <code>JanusPlugin</code> class, which provides common functionality for plugin lifecycle management, message handling, and WebRTC signaling.</p>"},{"location":"plugins/#janus_client.plugin_base.JanusPlugin","title":"janus_client.plugin_base.JanusPlugin","text":"<pre><code>JanusPlugin()\n</code></pre> <p>             Bases: <code>ABC</code></p> <p>Base class to inherit when implementing a plugin</p>"},{"location":"plugins/#janus_client.plugin_base.JanusPlugin-attributes","title":"Attributes","text":""},{"location":"plugins/#janus_client.plugin_base.JanusPlugin.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = 'janus.plugin.base.dummy'\n</code></pre> <p>Plugin name</p> <p>Must override to match plugin name in Janus server.</p>"},{"location":"plugins/#janus_client.plugin_base.JanusPlugin.id","title":"id  <code>property</code>","text":"<pre><code>id: int\n</code></pre>"},{"location":"plugins/#janus_client.plugin_base.JanusPlugin-functions","title":"Functions","text":""},{"location":"plugins/#janus_client.plugin_base.JanusPlugin.attach","title":"attach  <code>async</code>","text":"<pre><code>attach(session: JanusSession)\n</code></pre>"},{"location":"plugins/#janus_client.plugin_base.JanusPlugin.destroy","title":"destroy  <code>async</code>","text":"<pre><code>destroy()\n</code></pre> <p>Destroy plugin handle</p>"},{"location":"plugins/#janus_client.plugin_base.JanusPlugin.send","title":"send  <code>async</code>","text":"<pre><code>send(message: dict) -&gt; MessageTransaction\n</code></pre> <p>Send raw message to plugin</p> <p>Will auto attach plugin ID to the message.</p> <p>:param message: JSON serializable dictionary to send :return: Synchronous reply from server</p>"},{"location":"plugins/#janus_client.plugin_base.JanusPlugin.on_receive","title":"on_receive  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>on_receive(response: dict)\n</code></pre> <p>Handle asynchronous events from Janus</p>"},{"location":"plugins/#janus_client.plugin_base.JanusPlugin.create_jsep","title":"create_jsep  <code>async</code>","text":"<pre><code>create_jsep(pc: RTCPeerConnection, trickle: bool = False) -&gt; dict\n</code></pre>"},{"location":"plugins/#janus_client.plugin_base.JanusPlugin.on_receive_jsep","title":"on_receive_jsep  <code>async</code>","text":"<pre><code>on_receive_jsep(jsep: dict)\n</code></pre>"},{"location":"plugins/#janus_client.plugin_base.JanusPlugin.trickle","title":"trickle  <code>async</code>","text":"<pre><code>trickle(sdpMLineIndex, candidate)\n</code></pre> <p>Send WebRTC candidates to Janus</p> <p>:param sdpMLineIndex: (I don't know what is this) :param candidate: Candidate payload. (I got it from WebRTC instance callback)</p>"},{"location":"plugins/#echotest-plugin","title":"EchoTest Plugin","text":"<p>The EchoTest plugin is useful for testing WebRTC connectivity. It echoes back any media sent to it, making it perfect for testing your setup.</p>"},{"location":"plugins/#janus_client.plugin_echotest.JanusEchoTestPlugin","title":"janus_client.plugin_echotest.JanusEchoTestPlugin","text":"<pre><code>JanusEchoTestPlugin()\n</code></pre> <p>             Bases: <code>JanusPlugin</code></p> <p>Janus EchoTest plugin implementation</p>"},{"location":"plugins/#janus_client.plugin_echotest.JanusEchoTestPlugin-attributes","title":"Attributes","text":""},{"location":"plugins/#janus_client.plugin_echotest.JanusEchoTestPlugin.id","title":"id  <code>property</code>","text":"<pre><code>id: int\n</code></pre>"},{"location":"plugins/#janus_client.plugin_echotest.JanusEchoTestPlugin.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'janus.plugin.echotest'\n</code></pre>"},{"location":"plugins/#janus_client.plugin_echotest.JanusEchoTestPlugin-functions","title":"Functions","text":""},{"location":"plugins/#janus_client.plugin_echotest.JanusEchoTestPlugin.attach","title":"attach  <code>async</code>","text":"<pre><code>attach(session: JanusSession)\n</code></pre>"},{"location":"plugins/#janus_client.plugin_echotest.JanusEchoTestPlugin.destroy","title":"destroy  <code>async</code>","text":"<pre><code>destroy()\n</code></pre> <p>Destroy plugin handle</p>"},{"location":"plugins/#janus_client.plugin_echotest.JanusEchoTestPlugin.send","title":"send  <code>async</code>","text":"<pre><code>send(message: dict) -&gt; MessageTransaction\n</code></pre> <p>Send raw message to plugin</p> <p>Will auto attach plugin ID to the message.</p> <p>:param message: JSON serializable dictionary to send :return: Synchronous reply from server</p>"},{"location":"plugins/#janus_client.plugin_echotest.JanusEchoTestPlugin.create_jsep","title":"create_jsep  <code>async</code>","text":"<pre><code>create_jsep(pc: RTCPeerConnection, trickle: bool = False) -&gt; dict\n</code></pre>"},{"location":"plugins/#janus_client.plugin_echotest.JanusEchoTestPlugin.trickle","title":"trickle  <code>async</code>","text":"<pre><code>trickle(sdpMLineIndex, candidate)\n</code></pre> <p>Send WebRTC candidates to Janus</p> <p>:param sdpMLineIndex: (I don't know what is this) :param candidate: Candidate payload. (I got it from WebRTC instance callback)</p>"},{"location":"plugins/#janus_client.plugin_echotest.JanusEchoTestPlugin.on_receive","title":"on_receive  <code>async</code>","text":"<pre><code>on_receive(response: dict)\n</code></pre>"},{"location":"plugins/#janus_client.plugin_echotest.JanusEchoTestPlugin.wait_webrtcup","title":"wait_webrtcup  <code>async</code>","text":"<pre><code>wait_webrtcup() -&gt; None\n</code></pre>"},{"location":"plugins/#janus_client.plugin_echotest.JanusEchoTestPlugin.on_receive_jsep","title":"on_receive_jsep  <code>async</code>","text":"<pre><code>on_receive_jsep(jsep: dict)\n</code></pre>"},{"location":"plugins/#janus_client.plugin_echotest.JanusEchoTestPlugin.start","title":"start  <code>async</code>","text":"<pre><code>start(play_from: str, record_to: str = '')\n</code></pre>"},{"location":"plugins/#janus_client.plugin_echotest.JanusEchoTestPlugin.close_stream","title":"close_stream  <code>async</code>","text":"<pre><code>close_stream()\n</code></pre> <p>Close stream</p> <p>This should cause the stream to stop and a done event to be received.</p>"},{"location":"plugins/#echotest-usage-example","title":"EchoTest Usage Example","text":"<pre><code>import asyncio\nfrom janus_client import JanusSession, JanusEchoTestPlugin\n\nasync def main():\n    session = JanusSession(base_url=\"wss://example.com/janus\")\n    plugin = JanusEchoTestPlugin()\n\n    async with session:\n        await plugin.attach(session)\n\n        # Start echo test with media files\n        await plugin.start(input_file=\"input.mp4\", output_file=\"echo_output.mp4\")\n\n        # Let it run for a while\n        await asyncio.sleep(10)\n\n        # Stop echo test\n        await plugin.stop()\n        await plugin.destroy()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"plugins/#videocall-plugin","title":"VideoCall Plugin","text":"<p>The VideoCall plugin enables one-to-one video calls between users. It handles user registration, call initiation, and call management.</p>"},{"location":"plugins/#janus_client.plugin_video_call.JanusVideoCallPlugin","title":"janus_client.plugin_video_call.JanusVideoCallPlugin","text":"<pre><code>JanusVideoCallPlugin()\n</code></pre> <p>             Bases: <code>JanusPlugin</code></p> <p>Janus Video Call plugin implementation</p>"},{"location":"plugins/#janus_client.plugin_video_call.JanusVideoCallPlugin-attributes","title":"Attributes","text":""},{"location":"plugins/#janus_client.plugin_video_call.JanusVideoCallPlugin.id","title":"id  <code>property</code>","text":"<pre><code>id: int\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_call.JanusVideoCallPlugin.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'janus.plugin.videocall'\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_call.JanusVideoCallPlugin-functions","title":"Functions","text":""},{"location":"plugins/#janus_client.plugin_video_call.JanusVideoCallPlugin.attach","title":"attach  <code>async</code>","text":"<pre><code>attach(session: JanusSession)\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_call.JanusVideoCallPlugin.destroy","title":"destroy  <code>async</code>","text":"<pre><code>destroy()\n</code></pre> <p>Destroy plugin handle</p>"},{"location":"plugins/#janus_client.plugin_video_call.JanusVideoCallPlugin.send","title":"send  <code>async</code>","text":"<pre><code>send(message: dict) -&gt; MessageTransaction\n</code></pre> <p>Send raw message to plugin</p> <p>Will auto attach plugin ID to the message.</p> <p>:param message: JSON serializable dictionary to send :return: Synchronous reply from server</p>"},{"location":"plugins/#janus_client.plugin_video_call.JanusVideoCallPlugin.create_jsep","title":"create_jsep  <code>async</code>","text":"<pre><code>create_jsep(pc: RTCPeerConnection, trickle: bool = False) -&gt; dict\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_call.JanusVideoCallPlugin.trickle","title":"trickle  <code>async</code>","text":"<pre><code>trickle(sdpMLineIndex, candidate)\n</code></pre> <p>Send WebRTC candidates to Janus</p> <p>:param sdpMLineIndex: (I don't know what is this) :param candidate: Candidate payload. (I got it from WebRTC instance callback)</p>"},{"location":"plugins/#janus_client.plugin_video_call.JanusVideoCallPlugin.on_receive","title":"on_receive  <code>async</code>","text":"<pre><code>on_receive(response: dict)\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_call.JanusVideoCallPlugin.on_receive_jsep","title":"on_receive_jsep  <code>async</code>","text":"<pre><code>on_receive_jsep(jsep: dict)\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_call.JanusVideoCallPlugin.create_pc","title":"create_pc  <code>async</code>","text":"<pre><code>create_pc(player: MediaPlayer, recorder: MediaRecorder = None, jsep: dict = {}) -&gt; RTCPeerConnection\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_call.JanusVideoCallPlugin.on_incoming_call","title":"on_incoming_call  <code>async</code>","text":"<pre><code>on_incoming_call(jsep: dict)\n</code></pre> <p>Override this. This will be called when plugin receive incoming call event</p>"},{"location":"plugins/#janus_client.plugin_video_call.JanusVideoCallPlugin.send_wrapper","title":"send_wrapper  <code>async</code>","text":"<pre><code>send_wrapper(message: dict, matcher: dict, jsep: dict = {}) -&gt; dict\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_call.JanusVideoCallPlugin.list","title":"list  <code>async</code>","text":"<pre><code>list() -&gt; list\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_call.JanusVideoCallPlugin.register","title":"register  <code>async</code>","text":"<pre><code>register(username: str) -&gt; bool\n</code></pre> <p>Register a username</p> <p>Detach plugin to de-register the username</p>"},{"location":"plugins/#janus_client.plugin_video_call.JanusVideoCallPlugin.call","title":"call  <code>async</code>","text":"<pre><code>call(username: str, player: MediaPlayer, recorder: MediaRecorder = None) -&gt; bool\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_call.JanusVideoCallPlugin.accept","title":"accept  <code>async</code>","text":"<pre><code>accept(jsep: dict, pc: RTCPeerConnection, player: MediaPlayer, recorder: MediaRecorder = None) -&gt; bool\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_call.JanusVideoCallPlugin.set","title":"set  <code>async</code>","text":"<pre><code>set(audio: bool, video: bool, jsep: dict = {}) -&gt; bool\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_call.JanusVideoCallPlugin.hangup","title":"hangup  <code>async</code>","text":"<pre><code>hangup() -&gt; bool\n</code></pre>"},{"location":"plugins/#videocall-usage-example","title":"VideoCall Usage Example","text":"<pre><code>import asyncio\nfrom janus_client import JanusSession, JanusVideoCallPlugin\nfrom aiortc.contrib.media import MediaPlayer, MediaRecorder\n\nasync def main():\n    session = JanusSession(base_url=\"wss://example.com/janus\")\n    plugin = JanusVideoCallPlugin()\n\n    async with session:\n        await plugin.attach(session)\n\n        # Register with a username\n        await plugin.register(username=\"caller\")\n\n        # Make a call\n        player = MediaPlayer(\"input.mp4\")\n        recorder = MediaRecorder(\"output.mp4\")\n        await plugin.call(username=\"callee\", player=player, recorder=recorder)\n\n        # Wait for call duration\n        await asyncio.sleep(30)\n\n        # Hang up\n        await plugin.hangup()\n        await plugin.destroy()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"plugins/#videoroom-plugin","title":"VideoRoom Plugin","text":"<p>The VideoRoom plugin enables multi-party video conferencing. It supports room management, publishing, and subscribing to multiple video feeds.</p>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin","title":"janus_client.plugin_video_room.JanusVideoRoomPlugin","text":"<pre><code>JanusVideoRoomPlugin(*args, **kwargs)\n</code></pre> <p>             Bases: <code>JanusPlugin</code></p> <p>Janus VideoRoom plugin implementation</p> <p>Implements API to interact with VideoRoom plugin.</p> <p>Each plugin object is expected to have only 1 PeerConnection.</p> <p>Each VideoRoom plugin instance is expected to have one of the following three uses: - Administration - Publisher - Subscriber</p> <p>An instance meant for administration can be used as publisher or subscriber, but usually there isn't a reason to share. Just create another instance. On the other hand, a publisher instance cannot subscribe to a stream and vice versa.</p>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin-attributes","title":"Attributes","text":""},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.id","title":"id  <code>property</code>","text":"<pre><code>id: int\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'janus.plugin.videoroom'\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin-classes","title":"Classes","text":""},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.State","title":"State","text":""},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.State-attributes","title":"Attributes","text":""},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.State.STREAMING_OUT_MEDIA","title":"STREAMING_OUT_MEDIA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STREAMING_OUT_MEDIA = 'streaming_out_media'\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.State.STREAMING_IN_MEDIA","title":"STREAMING_IN_MEDIA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STREAMING_IN_MEDIA = 'streaming_in_media'\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.State.IDLE","title":"IDLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IDLE = 'idle'\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin-functions","title":"Functions","text":""},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.attach","title":"attach  <code>async</code>","text":"<pre><code>attach(session: JanusSession)\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.destroy","title":"destroy  <code>async</code>","text":"<pre><code>destroy()\n</code></pre> <p>Destroy plugin handle</p>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.send","title":"send  <code>async</code>","text":"<pre><code>send(message: dict) -&gt; MessageTransaction\n</code></pre> <p>Send raw message to plugin</p> <p>Will auto attach plugin ID to the message.</p> <p>:param message: JSON serializable dictionary to send :return: Synchronous reply from server</p>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.create_jsep","title":"create_jsep  <code>async</code>","text":"<pre><code>create_jsep(pc: RTCPeerConnection, trickle: bool = False) -&gt; dict\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.on_receive_jsep","title":"on_receive_jsep  <code>async</code>","text":"<pre><code>on_receive_jsep(jsep: dict)\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.trickle","title":"trickle  <code>async</code>","text":"<pre><code>trickle(sdpMLineIndex, candidate)\n</code></pre> <p>Send WebRTC candidates to Janus</p> <p>:param sdpMLineIndex: (I don't know what is this) :param candidate: Candidate payload. (I got it from WebRTC instance callback)</p>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.on_receive","title":"on_receive  <code>async</code>","text":"<pre><code>on_receive(response: dict)\n</code></pre> <p>Handle asynchronous messages</p>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.send_wrapper","title":"send_wrapper  <code>async</code>","text":"<pre><code>send_wrapper(message: dict, matcher: dict, jsep: dict = {}) -&gt; dict\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.create_room","title":"create_room  <code>async</code>","text":"<pre><code>create_room(room_id: int, configuration: dict = {}) -&gt; bool\n</code></pre> <p>Create a room.</p> <p>Refer to documentation for description of parameters. https://janus.conf.meetecho.com/docs/videoroom.html</p>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.destroy_room","title":"destroy_room  <code>async</code>","text":"<pre><code>destroy_room(room_id: int, secret: str = '', permanent: bool = False) -&gt; bool\n</code></pre> <p>Destroy a room.</p> <p>All other participants in the room will also get the \"destroyed\" event.</p>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.edit","title":"edit  <code>async</code>","text":"<pre><code>edit(room_id: int, secret: str = '', new_description: str = '', new_secret: str = '', new_pin: str = '', new_is_private: bool = False, new_require_pvtid: bool = False, new_bitrate: int = None, new_fir_freq: int = None, new_publishers: int = 3, new_lock_record: bool = False, new_rec_dir: str = None, permanent: bool = False) -&gt; bool\n</code></pre> <p>Edit a room.</p>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.exists","title":"exists  <code>async</code>","text":"<pre><code>exists(room_id: int) -&gt; bool\n</code></pre> <p>Check if a room exists.</p>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.allowed","title":"allowed  <code>async</code>","text":"<pre><code>allowed(room_id: int, secret: str = '', action: AllowedAction = AllowedAction.ENABLE, allowed: List[str] = []) -&gt; bool\n</code></pre> <p>Configure ACL of a room.</p>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.kick","title":"kick  <code>async</code>","text":"<pre><code>kick(room_id: int, id: str, secret: str = '') -&gt; bool\n</code></pre> <p>Kick a participant by ID.</p> <p>Only works for room administrators (i.e. you created the room).</p>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.moderate","title":"moderate  <code>async</code>","text":"<pre><code>moderate(room_id: int, id: str, mid: str, mute: bool, secret: str = '') -&gt; bool\n</code></pre> <p>Moderate a participant by ID.</p> <p>Only works for room administrators (i.e. you created the room).</p>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.list_room","title":"list_room  <code>async</code>","text":"<pre><code>list_room() -&gt; List[dict]\n</code></pre> <p>List all rooms created.</p> <p>If admin_key is included, then private rooms will be listed as well. TODO: Find out how to include admin_key.</p>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.list_participants","title":"list_participants  <code>async</code>","text":"<pre><code>list_participants(room_id: int) -&gt; list\n</code></pre> <p>Get participant list in a room</p> <p>Get a list of publishers in the room, that are currently publishing.</p> <p>:param room_id: List participants in this room :return: A list containing the participants. Can be empty.</p>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.join","title":"join  <code>async</code>","text":"<pre><code>join(room_id: int, publisher_id: int = None, display_name: str = '', token: str = None) -&gt; bool\n</code></pre> <p>Join a room</p> <p>A handle can join a room and then do nothing, but this should be called before publishing. There is an API to configure and publish at the same time, but it's not implemented yet.</p> <p>:param room_id: unique ID of the room to join. :param publisher_id: unique ID to register for the publisher; optional, will be chosen by the plugin if missing. :param display_name: display name for the publisher; optional. :param token: invitation token, in case the room has an ACL; optional.</p> <p>:return: True if room is created.</p>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.leave","title":"leave  <code>async</code>","text":"<pre><code>leave() -&gt; bool\n</code></pre> <p>Leave the room. Will unpublish if publishing.</p> <p>:return: True if successfully leave.</p>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.create_pc","title":"create_pc  <code>async</code>","text":"<pre><code>create_pc(stream_track: List[MediaStreamTrack] = [], jsep: dict = {}) -&gt; RTCPeerConnection\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(stream_track: List[MediaStreamTrack], configuration: dict = {}) -&gt; None\n</code></pre> <p>Publish video stream to the room</p> <p>Should already have joined a room before this.</p>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.unpublish","title":"unpublish  <code>async</code>","text":"<pre><code>unpublish() -&gt; bool\n</code></pre> <p>Stop publishing.</p> <p>:return: True if successfully unpublished.</p>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.subscribe_and_start","title":"subscribe_and_start  <code>async</code>","text":"<pre><code>subscribe_and_start(room_id: int, on_track_created, stream: dict, use_msid: bool = False, autoupdate: bool = True, private_id: int = None) -&gt; bool\n</code></pre> <p>Subscribe to a feed. Only supporting subscribe to 1 stream.</p> <p>:param room_id: Room ID containing the feed. The same ID that     you would use to join the room. :param on_track_created: A callback function that will be called when AIORTC PC creates     a media track :param stream: Configuration of the stream to subscribe to. Minimum should have     a feed ID. :param use_msid: whether subscriptions should include an msid that references the publisher; false by default. :param autoupdate: whether a new SDP offer is sent automatically when a subscribed publisher leaves; true by default. :param private_id: unique ID of the publisher that originated this request; optional, unless mandated by the room configuration.</p>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.unsubscribe","title":"unsubscribe  <code>async</code>","text":"<pre><code>unsubscribe() -&gt; None\n</code></pre> <p>Unsubscribe from the feed</p>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.start","title":"start  <code>async</code>","text":"<pre><code>start(jsep: dict = None) -&gt; bool\n</code></pre> <p>Signal WebRTC start.</p>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.pause","title":"pause  <code>async</code>","text":"<pre><code>pause() -&gt; None\n</code></pre> <p>Pause media streaming</p>"},{"location":"plugins/#videoroom-state-class","title":"VideoRoom State Class","text":""},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.State","title":"janus_client.plugin_video_room.JanusVideoRoomPlugin.State","text":""},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.State-attributes","title":"Attributes","text":""},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.State.STREAMING_OUT_MEDIA","title":"STREAMING_OUT_MEDIA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STREAMING_OUT_MEDIA = 'streaming_out_media'\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.State.STREAMING_IN_MEDIA","title":"STREAMING_IN_MEDIA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STREAMING_IN_MEDIA = 'streaming_in_media'\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_room.JanusVideoRoomPlugin.State.IDLE","title":"IDLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IDLE = 'idle'\n</code></pre>"},{"location":"plugins/#allowedaction-enum","title":"AllowedAction Enum","text":""},{"location":"plugins/#janus_client.plugin_video_room.AllowedAction","title":"janus_client.plugin_video_room.AllowedAction","text":"<p>             Bases: <code>Enum</code></p>"},{"location":"plugins/#janus_client.plugin_video_room.AllowedAction-attributes","title":"Attributes","text":""},{"location":"plugins/#janus_client.plugin_video_room.AllowedAction.ENABLE","title":"ENABLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ENABLE = 'enable'\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_room.AllowedAction.DISABLE","title":"DISABLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DISABLE = 'disable'\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_room.AllowedAction.ADD","title":"ADD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ADD = 'add'\n</code></pre>"},{"location":"plugins/#janus_client.plugin_video_room.AllowedAction.REMOVE","title":"REMOVE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REMOVE = 'remove'\n</code></pre>"},{"location":"plugins/#videoroom-usage-example","title":"VideoRoom Usage Example","text":"<pre><code>import asyncio\nfrom janus_client import JanusSession, JanusVideoRoomPlugin\nfrom aiortc.contrib.media import MediaPlayer, MediaRecorder\n\nasync def main():\n    session = JanusSession(base_url=\"wss://example.com/janus\")\n    plugin = JanusVideoRoomPlugin()\n\n    async with session:\n        await plugin.attach(session)\n\n        # Join a room\n        await plugin.join(room_id=1234, username=\"user1\")\n\n        # Start publishing media\n        player = MediaPlayer(\"video.mp4\")\n        await plugin.publish(player=player)\n\n        # Subscribe to another participant's feed\n        recorder = MediaRecorder(\"output.mp4\")\n        await plugin.subscribe_and_start(feed_id=5678, recorder=recorder)\n\n        # Wait and then cleanup\n        await asyncio.sleep(30)\n        await plugin.unpublish()\n        await plugin.unsubscribe()\n        await plugin.leave()\n        await plugin.destroy()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"plugins/#plugin-development-guidelines","title":"Plugin Development Guidelines","text":""},{"location":"plugins/#creating-custom-plugins","title":"Creating Custom Plugins","text":"<p>To create a custom plugin, inherit from <code>JanusPlugin</code> and implement the required methods:</p> <pre><code>from janus_client import JanusPlugin\nfrom typing import Dict, Any, Optional\n\nclass MyCustomPlugin(JanusPlugin):\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self._state = {}\n\n    async def on_receive(self, response: Dict[str, Any]) -&gt; None:\n        \"\"\"Handle plugin-specific messages.\"\"\"\n        if \"plugindata\" in response:\n            data = response[\"plugindata\"][\"data\"]\n            # Handle plugin data\n            pass\n\n    async def on_receive_jsep(self, jsep: Dict[str, Any]) -&gt; None:\n        \"\"\"Handle WebRTC signaling.\"\"\"\n        if jsep[\"type\"] == \"offer\":\n            # Handle offer\n            pass\n        elif jsep[\"type\"] == \"answer\":\n            # Handle answer\n            pass\n\n    async def custom_action(self, param: str) -&gt; bool:\n        \"\"\"Custom plugin action.\"\"\"\n        message = {\"request\": \"custom\", \"param\": param}\n        response = await self.send(message)\n        return response.get(\"success\", False)\n</code></pre>"},{"location":"plugins/#plugin-lifecycle","title":"Plugin Lifecycle","text":"<p>All plugins follow a standard lifecycle:</p> <ol> <li>Creation: Instantiate the plugin class</li> <li>Attachment: Attach to a session using <code>attach(session)</code></li> <li>Usage: Call plugin-specific methods</li> <li>Cleanup: Destroy the plugin using <code>destroy()</code></li> </ol>"},{"location":"plugins/#message-handling","title":"Message Handling","text":"<p>Plugins receive two types of messages:</p> <ul> <li>Plugin Messages: Handled by <code>on_receive()</code> method</li> <li>JSEP Messages: WebRTC signaling handled by <code>on_receive_jsep()</code> method</li> </ul>"},{"location":"plugins/#webrtc-integration","title":"WebRTC Integration","text":"<p>Plugins that handle media use aiortc for WebRTC functionality:</p> <ul> <li>MediaPlayer: For input media (files, devices, streams)</li> <li>MediaRecorder: For output media recording</li> <li>RTCPeerConnection: For WebRTC peer connections</li> <li>MediaStreamTrack: For handling individual media tracks</li> </ul>"},{"location":"plugins/#best-practices","title":"Best Practices","text":""},{"location":"plugins/#plugin-usage","title":"Plugin Usage","text":"<ol> <li>Always destroy plugins: Use <code>await plugin.destroy()</code> when done</li> <li>Handle errors gracefully: Wrap plugin operations in try-except blocks</li> <li>Use context managers: Consider implementing <code>__aenter__</code> and <code>__aexit__</code> for custom plugins</li> <li>Check plugin state: Verify plugin is attached before calling methods</li> </ol>"},{"location":"plugins/#media-handling","title":"Media Handling","text":"<ol> <li>Resource cleanup: Always stop MediaPlayer and MediaRecorder instances</li> <li>Track management: Handle track events properly in <code>on_track</code> callbacks</li> <li>Codec compatibility: Ensure media formats are supported by Janus</li> <li>Performance: Monitor memory usage with long-running media operations</li> </ol>"},{"location":"plugins/#error-handling","title":"Error Handling","text":"<pre><code>async def safe_plugin_usage():\n    session = JanusSession(base_url=\"wss://example.com/janus\")\n    plugin = JanusVideoRoomPlugin()\n\n    try:\n        async with session:\n            await plugin.attach(session)\n\n            # Plugin operations\n            await plugin.join(room_id=1234, username=\"user1\")\n\n    except Exception as e:\n        logger.error(f\"Plugin error: {e}\")\n    finally:\n        # Ensure cleanup\n        try:\n            await plugin.destroy()\n        except:\n            pass\n</code></pre>"},{"location":"plugins/#concurrent-plugin-usage","title":"Concurrent Plugin Usage","text":"<p>When using multiple plugins with the same session, be careful about message routing:</p> <p>```python async def multiple_plugins():     session = JanusSession(base_url=\"wss://example.com/janus\")</p> <pre><code>async with session:\n    # Sequential plugin usage (recommended)\n    plugin1 = JanusEchoTestPlugin()\n    await plugin1.attach(session)\n    await plugin1.start(\"input1.mp4\")\n    await plugin1.destroy()\n\n    plugin2 = JanusVideoCallPlugin()\n    await plugin2.attach(session)\n    await plugin2.register(\"user1\")\n    await plugin2.destroy()\n</code></pre>"},{"location":"session/","title":"Session","text":"<p>Create a session object that can be shared between plugin handles.</p> <p>The session is the main entry point for communicating with a Janus WebRTC Gateway server. It manages the connection, handles message routing, and provides lifecycle management for plugins.</p>"},{"location":"session/#janussession","title":"JanusSession","text":""},{"location":"session/#janus_client.session.JanusSession","title":"janus_client.session.JanusSession","text":"<pre><code>JanusSession(base_url: str = '', api_secret: str = None, token: str = None, transport: JanusTransport = None)\n</code></pre> <p>Janus session instance</p>"},{"location":"session/#janus_client.session.JanusSession-attributes","title":"Attributes","text":""},{"location":"session/#janus_client.session.JanusSession.transport","title":"transport  <code>instance-attribute</code>","text":"<pre><code>transport: JanusTransport\n</code></pre>"},{"location":"session/#janus_client.session.JanusSession.created","title":"created  <code>instance-attribute</code>","text":"<pre><code>created: bool = False\n</code></pre>"},{"location":"session/#janus_client.session.JanusSession.plugin_handles","title":"plugin_handles  <code>instance-attribute</code>","text":"<pre><code>plugin_handles: Dict[int, JanusPlugin] = dict()\n</code></pre>"},{"location":"session/#janus_client.session.JanusSession-functions","title":"Functions","text":""},{"location":"session/#janus_client.session.JanusSession.create","title":"create  <code>async</code>","text":"<pre><code>create() -&gt; None\n</code></pre> <p>Initialize resources</p>"},{"location":"session/#janus_client.session.JanusSession.destroy","title":"destroy  <code>async</code>","text":"<pre><code>destroy() -&gt; None\n</code></pre> <p>Release resources</p> <p>| Should be called when you don't need the session anymore. | Plugins from this session should be destroyed before this.</p>"},{"location":"session/#janus_client.session.JanusSession.send","title":"send  <code>async</code>","text":"<pre><code>send(message: dict, handle_id: int = None) -&gt; MessageTransaction\n</code></pre>"},{"location":"session/#janus_client.session.JanusSession.keepalive","title":"keepalive  <code>async</code>","text":"<pre><code>keepalive() -&gt; None\n</code></pre>"},{"location":"session/#janus_client.session.JanusSession.on_receive","title":"on_receive  <code>async</code>","text":"<pre><code>on_receive(response: dict)\n</code></pre>"},{"location":"session/#janus_client.session.JanusSession.attach_plugin","title":"attach_plugin  <code>async</code>","text":"<pre><code>attach_plugin(plugin: JanusPlugin) -&gt; int\n</code></pre> <p>Create plugin handle for the given plugin type</p> <p>:param plugin: Plugin instance with janus_client.JanusPlugin as base class</p>"},{"location":"session/#janus_client.session.JanusSession.detach_plugin","title":"detach_plugin","text":"<pre><code>detach_plugin(plugin_handle: JanusPlugin)\n</code></pre>"},{"location":"session/#pluginattachfail-exception","title":"PluginAttachFail Exception","text":""},{"location":"session/#janus_client.session.PluginAttachFail","title":"janus_client.session.PluginAttachFail","text":"<pre><code>PluginAttachFail(response)\n</code></pre> <p>             Bases: <code>Exception</code></p>"},{"location":"session/#usage-examples","title":"Usage Examples","text":""},{"location":"session/#basic-session-usage","title":"Basic Session Usage","text":"<pre><code>import asyncio\nfrom janus_client import JanusSession, JanusEchoTestPlugin\n\nasync def main():\n    # Create session\n    session = JanusSession(base_url=\"wss://example.com/janus\")\n\n    try:\n        # Use session as async context manager for automatic cleanup\n        async with session:\n            # Create and attach plugin\n            plugin = JanusEchoTestPlugin()\n            await plugin.attach(session)\n\n            # Use plugin...\n            await plugin.start(\"input.mp4\", \"output.mp4\")\n            await asyncio.sleep(10)\n\n            # Plugin will be automatically destroyed when session closes\n\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"session/#manual-session-management","title":"Manual Session Management","text":"<pre><code>import asyncio\nfrom janus_client import JanusSession, JanusVideoRoomPlugin\n\nasync def main():\n    session = JanusSession(base_url=\"https://example.com/janus\")\n\n    try:\n        # Manually create session\n        await session.create()\n\n        # Attach plugin\n        plugin = JanusVideoRoomPlugin()\n        await plugin.attach(session)\n\n        # Use plugin\n        await plugin.join(room_id=1234, username=\"user1\")\n\n        # Manual cleanup\n        await plugin.destroy()\n        await session.destroy()\n\n    except Exception as e:\n        print(f\"Error: {e}\")\n        # Ensure cleanup on error\n        try:\n            await session.destroy()\n        except:\n            pass\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"session/#session-with-custom-transport-options","title":"Session with Custom Transport Options","text":"<pre><code>import asyncio\nfrom janus_client import JanusSession\n\nasync def main():\n    # Session with custom transport configuration\n    session = JanusSession(\n        base_url=\"wss://example.com/janus\",\n        timeout=30.0,           # Request timeout\n        max_retries=3,          # Maximum retry attempts\n        retry_delay=1.0,        # Initial retry delay\n        keepalive_interval=30   # Keepalive ping interval\n    )\n\n    async with session:\n        # Get server information\n        info = await session.transport.info()\n        print(f\"Server info: {info}\")\n\n        # Send keepalive ping\n        await session.keepalive()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"session/#best-practices","title":"Best Practices","text":""},{"location":"session/#always-use-context-managers","title":"Always Use Context Managers","text":"<p>The recommended way to use sessions is with async context managers (<code>async with</code>), which ensures proper cleanup:</p> <pre><code>async with session:\n    # Your code here\n    pass\n# Session is automatically destroyed here\n</code></pre>"},{"location":"session/#error-handling","title":"Error Handling","text":"<p>Always wrap session operations in try-except blocks to handle connection failures:</p> <pre><code>try:\n    async with session:\n        # Session operations\n        pass\nexcept ConnectionError:\n    print(\"Failed to connect to Janus server\")\nexcept TimeoutError:\n    print(\"Operation timed out\")\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"session/#plugin-lifecycle","title":"Plugin Lifecycle","text":"<p>Plugins attached to a session should be properly destroyed:</p> <pre><code>async with session:\n    plugin = JanusEchoTestPlugin()\n    try:\n        await plugin.attach(session)\n        # Use plugin\n    finally:\n        await plugin.destroy()  # Explicit cleanup\n</code></pre>"},{"location":"session/#connection-reuse","title":"Connection Reuse","text":"<p>Sessions can be reused for multiple operations, but should not be shared across different async tasks without proper synchronization:</p> <p>```python</p>"},{"location":"session/#good-sequential-operations","title":"Good: Sequential operations","text":"<p>async with session:     plugin1 = JanusEchoTestPlugin()     await plugin1.attach(session)     await plugin1.start(\"input1.mp4\")     await plugin1.destroy()</p> <pre><code>plugin2 = JanusVideoCallPlugin()\nawait plugin2.attach(session)\nawait plugin2.register(\"user1\")\nawait plugin2.destroy()\n</code></pre>"},{"location":"session/#avoid-concurrent-access-without-synchronization","title":"Avoid: Concurrent access without synchronization","text":""},{"location":"session/#multiple-plugins-using-the-same-session-concurrently","title":"Multiple plugins using the same session concurrently","text":""},{"location":"session/#requires-careful-message-handling","title":"requires careful message handling","text":""},{"location":"transport/","title":"Transport","text":"<p>Transport classes handle the actual communication with the Janus server. The transport method is automatically detected using regex patterns on the base_url parameter passed to the Session object.</p> <p>The transport layer provides an abstraction over different communication protocols (HTTP, WebSocket) and handles connection management, message routing, and error recovery.</p>"},{"location":"transport/#base-transport-class","title":"Base Transport Class","text":"<p>All transport implementations inherit from the base <code>JanusTransport</code> class, which defines the common interface and functionality.</p>"},{"location":"transport/#janus_client.transport.JanusTransport","title":"janus_client.transport.JanusTransport","text":"<pre><code>JanusTransport(base_url: str, api_secret: str = None, token: str = None, **kwargs: dict)\n</code></pre> <p>             Bases: <code>ABC</code></p> <p>Janus transport protocol interface</p> <p>Manage Sessions and Transactions</p> <p>Create connection instance</p> <p>:param base_url: Janus server address :param api_secret: (optional) API key for shared static secret authentication :param token: (optional) Token for shared token based authentication</p>"},{"location":"transport/#janus_client.transport.JanusTransport-attributes","title":"Attributes","text":""},{"location":"transport/#janus_client.transport.JanusTransport.connected","title":"connected  <code>instance-attribute</code>","text":"<pre><code>connected: bool = False\n</code></pre> <p>Must set this property when connected or disconnected</p>"},{"location":"transport/#janus_client.transport.JanusTransport.base_url","title":"base_url  <code>property</code>","text":"<pre><code>base_url: str\n</code></pre>"},{"location":"transport/#janus_client.transport.JanusTransport-functions","title":"Functions","text":""},{"location":"transport/#janus_client.transport.JanusTransport.info","title":"info  <code>async</code>","text":"<pre><code>info() -&gt; Dict\n</code></pre> <p>Get info of Janus server. Will be overridden for HTTP.</p>"},{"location":"transport/#janus_client.transport.JanusTransport.ping","title":"ping  <code>async</code>","text":"<pre><code>ping() -&gt; Dict\n</code></pre>"},{"location":"transport/#janus_client.transport.JanusTransport.dispatch_session_created","title":"dispatch_session_created  <code>async</code>","text":"<pre><code>dispatch_session_created(session_id: int) -&gt; None\n</code></pre> <p>Override this method to get session created event</p>"},{"location":"transport/#janus_client.transport.JanusTransport.dispatch_session_destroyed","title":"dispatch_session_destroyed  <code>async</code>","text":"<pre><code>dispatch_session_destroyed(session_id: int) -&gt; None\n</code></pre> <p>Override this method to get session destroyed event</p>"},{"location":"transport/#janus_client.transport.JanusTransport.connect","title":"connect  <code>async</code>","text":"<pre><code>connect() -&gt; None\n</code></pre> <p>Initialize resources</p>"},{"location":"transport/#janus_client.transport.JanusTransport.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Release resources</p>"},{"location":"transport/#janus_client.transport.JanusTransport.send","title":"send  <code>async</code>","text":"<pre><code>send(message: Dict, session_id: int = None, handle_id: int = None) -&gt; MessageTransaction\n</code></pre> <p>Send message to server</p> <p>:param message: JSON serializable dictionary to send</p> <p>:returns: Synchronous response from Janus server</p>"},{"location":"transport/#janus_client.transport.JanusTransport.receive","title":"receive  <code>async</code>","text":"<pre><code>receive(response: dict) -&gt; None\n</code></pre>"},{"location":"transport/#janus_client.transport.JanusTransport.create_session","title":"create_session  <code>async</code>","text":"<pre><code>create_session(session: JanusSession) -&gt; int\n</code></pre> <p>Create Janus Session</p>"},{"location":"transport/#janus_client.transport.JanusTransport.destroy_session","title":"destroy_session  <code>async</code>","text":"<pre><code>destroy_session(session_id: int) -&gt; None\n</code></pre>"},{"location":"transport/#janus_client.transport.JanusTransport.register_transport","title":"register_transport  <code>staticmethod</code>","text":"<pre><code>register_transport(protocol_matcher, transport_cls: JanusTransport) -&gt; None\n</code></pre> <p>Register transport class</p> <p>Pass in a regex matcher and it will be used to match base_url to the transport class.</p>"},{"location":"transport/#janus_client.transport.JanusTransport.create_transport","title":"create_transport  <code>staticmethod</code>","text":"<pre><code>create_transport(base_url: str, api_secret: str = None, token: str = None, config: Dict = {}) -&gt; JanusTransport\n</code></pre> <p>Create transport class</p> <p>JanusSession will call this to create the transport class automatically using base_url parameter.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>description</p> required <code>api_secret</code> <code>str</code> <p>description. Defaults to None.</p> <code>None</code> <code>token</code> <code>str</code> <p>description. Defaults to None.</p> <code>None</code> <code>config</code> <code>Dict</code> <p>description. Defaults to {}.</p> <code>{}</code> <p>Raises:</p> Type Description <code>Exception</code> <p>No transport class found</p> <code>Exception</code> <p>More than 1 transport class found</p> <p>Returns:</p> Name Type Description <code>JanusTransport</code> <code>JanusTransport</code> <p>Use this object to communicate with Janus server.</p>"},{"location":"transport/#http-transport","title":"HTTP Transport","text":"<p>The HTTP transport implementation provides communication with Janus server over HTTP/HTTPS using long polling for receiving messages.</p>"},{"location":"transport/#janus_client.transport_http.JanusTransportHTTP","title":"janus_client.transport_http.JanusTransportHTTP","text":"<pre><code>JanusTransportHTTP(base_url: str, api_secret: str = None, token: str = None, **kwargs: dict)\n</code></pre> <p>             Bases: <code>JanusTransport</code></p> <p>Janus transport through HTTP</p>"},{"location":"transport/#janus_client.transport_http.JanusTransportHTTP-attributes","title":"Attributes","text":""},{"location":"transport/#janus_client.transport_http.JanusTransportHTTP.connected","title":"connected  <code>instance-attribute</code>","text":"<pre><code>connected: bool = False\n</code></pre> <p>Must set this property when connected or disconnected</p>"},{"location":"transport/#janus_client.transport_http.JanusTransportHTTP.base_url","title":"base_url  <code>property</code>","text":"<pre><code>base_url: str\n</code></pre>"},{"location":"transport/#janus_client.transport_http.JanusTransportHTTP-functions","title":"Functions","text":""},{"location":"transport/#janus_client.transport_http.JanusTransportHTTP.ping","title":"ping  <code>async</code>","text":"<pre><code>ping() -&gt; Dict\n</code></pre>"},{"location":"transport/#janus_client.transport_http.JanusTransportHTTP.connect","title":"connect  <code>async</code>","text":"<pre><code>connect() -&gt; None\n</code></pre> <p>Initialize resources</p>"},{"location":"transport/#janus_client.transport_http.JanusTransportHTTP.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Release resources</p>"},{"location":"transport/#janus_client.transport_http.JanusTransportHTTP.send","title":"send  <code>async</code>","text":"<pre><code>send(message: Dict, session_id: int = None, handle_id: int = None) -&gt; MessageTransaction\n</code></pre> <p>Send message to server</p> <p>:param message: JSON serializable dictionary to send</p> <p>:returns: Synchronous response from Janus server</p>"},{"location":"transport/#janus_client.transport_http.JanusTransportHTTP.receive","title":"receive  <code>async</code>","text":"<pre><code>receive(response: dict) -&gt; None\n</code></pre>"},{"location":"transport/#janus_client.transport_http.JanusTransportHTTP.create_session","title":"create_session  <code>async</code>","text":"<pre><code>create_session(session: JanusSession) -&gt; int\n</code></pre> <p>Create Janus Session</p>"},{"location":"transport/#janus_client.transport_http.JanusTransportHTTP.destroy_session","title":"destroy_session  <code>async</code>","text":"<pre><code>destroy_session(session_id: int) -&gt; None\n</code></pre>"},{"location":"transport/#janus_client.transport_http.JanusTransportHTTP.register_transport","title":"register_transport  <code>staticmethod</code>","text":"<pre><code>register_transport(protocol_matcher, transport_cls: JanusTransport) -&gt; None\n</code></pre> <p>Register transport class</p> <p>Pass in a regex matcher and it will be used to match base_url to the transport class.</p>"},{"location":"transport/#janus_client.transport_http.JanusTransportHTTP.create_transport","title":"create_transport  <code>staticmethod</code>","text":"<pre><code>create_transport(base_url: str, api_secret: str = None, token: str = None, config: Dict = {}) -&gt; JanusTransport\n</code></pre> <p>Create transport class</p> <p>JanusSession will call this to create the transport class automatically using base_url parameter.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>description</p> required <code>api_secret</code> <code>str</code> <p>description. Defaults to None.</p> <code>None</code> <code>token</code> <code>str</code> <p>description. Defaults to None.</p> <code>None</code> <code>config</code> <code>Dict</code> <p>description. Defaults to {}.</p> <code>{}</code> <p>Raises:</p> Type Description <code>Exception</code> <p>No transport class found</p> <code>Exception</code> <p>More than 1 transport class found</p> <p>Returns:</p> Name Type Description <code>JanusTransport</code> <code>JanusTransport</code> <p>Use this object to communicate with Janus server.</p>"},{"location":"transport/#janus_client.transport_http.JanusTransportHTTP.info","title":"info  <code>async</code>","text":"<pre><code>info() -&gt; Dict\n</code></pre>"},{"location":"transport/#janus_client.transport_http.JanusTransportHTTP.session_receive_response_done_cb","title":"session_receive_response_done_cb","text":"<pre><code>session_receive_response_done_cb(task: Task, context=None) -&gt; None\n</code></pre>"},{"location":"transport/#janus_client.transport_http.JanusTransportHTTP.session_receive_response","title":"session_receive_response  <code>async</code>","text":"<pre><code>session_receive_response(session_id: str, destroyed_event: Event) -&gt; None\n</code></pre>"},{"location":"transport/#janus_client.transport_http.JanusTransportHTTP.dispatch_session_created","title":"dispatch_session_created  <code>async</code>","text":"<pre><code>dispatch_session_created(session_id: str) -&gt; None\n</code></pre>"},{"location":"transport/#janus_client.transport_http.JanusTransportHTTP.dispatch_session_destroyed","title":"dispatch_session_destroyed  <code>async</code>","text":"<pre><code>dispatch_session_destroyed(session_id: int) -&gt; None\n</code></pre>"},{"location":"transport/#http-transport-features","title":"HTTP Transport Features","text":"<ul> <li>Protocol Support: HTTP and HTTPS</li> <li>Long Polling: Efficient message receiving using long polling</li> <li>Connection Pooling: Reuses HTTP connections for efficiency</li> <li>Session Management: Automatic session lifecycle management</li> <li>Error Recovery: Automatic retry with exponential backoff</li> </ul>"},{"location":"transport/#http-transport-usage","title":"HTTP Transport Usage","text":"<pre><code>import asyncio\nfrom janus_client import JanusSession\n\nasync def main():\n    # HTTP transport will be automatically selected for http/https URLs\n    session = JanusSession(base_url=\"https://example.com/janus\")\n\n    async with session:\n        # Transport handles all HTTP communication automatically\n        info = await session.transport.info()\n        print(f\"Server info: {info}\")\n\n        # Send a ping to test connectivity\n        ping_response = await session.transport.ping()\n        print(f\"Ping response: {ping_response}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"transport/#websocket-transport","title":"WebSocket Transport","text":"<p>The WebSocket transport implementation provides real-time, full-duplex communication with the Janus server.</p>"},{"location":"transport/#janus_client.transport_websocket.JanusTransportWebsocket","title":"janus_client.transport_websocket.JanusTransportWebsocket","text":"<pre><code>JanusTransportWebsocket(**kwargs: dict)\n</code></pre> <p>             Bases: <code>JanusTransport</code></p> <p>Janus transport through HTTP</p> <p>Manage Sessions and Transactions</p>"},{"location":"transport/#janus_client.transport_websocket.JanusTransportWebsocket-attributes","title":"Attributes","text":""},{"location":"transport/#janus_client.transport_websocket.JanusTransportWebsocket.base_url","title":"base_url  <code>property</code>","text":"<pre><code>base_url: str\n</code></pre>"},{"location":"transport/#janus_client.transport_websocket.JanusTransportWebsocket.ws","title":"ws  <code>instance-attribute</code>","text":"<pre><code>ws: WebSocketClientProtocol\n</code></pre>"},{"location":"transport/#janus_client.transport_websocket.JanusTransportWebsocket.subprotocol","title":"subprotocol  <code>instance-attribute</code>","text":"<pre><code>subprotocol: str\n</code></pre>"},{"location":"transport/#janus_client.transport_websocket.JanusTransportWebsocket.connected","title":"connected  <code>instance-attribute</code>","text":"<pre><code>connected: bool = False\n</code></pre>"},{"location":"transport/#janus_client.transport_websocket.JanusTransportWebsocket.receiving_message","title":"receiving_message  <code>instance-attribute</code>","text":"<pre><code>receiving_message: bool = False\n</code></pre>"},{"location":"transport/#janus_client.transport_websocket.JanusTransportWebsocket.receive_message_task","title":"receive_message_task  <code>instance-attribute</code>","text":"<pre><code>receive_message_task: Task = None\n</code></pre>"},{"location":"transport/#janus_client.transport_websocket.JanusTransportWebsocket.receive_message_task_started","title":"receive_message_task_started  <code>instance-attribute</code>","text":"<pre><code>receive_message_task_started: Event = Event()\n</code></pre>"},{"location":"transport/#janus_client.transport_websocket.JanusTransportWebsocket-functions","title":"Functions","text":""},{"location":"transport/#janus_client.transport_websocket.JanusTransportWebsocket.info","title":"info  <code>async</code>","text":"<pre><code>info() -&gt; Dict\n</code></pre> <p>Get info of Janus server. Will be overridden for HTTP.</p>"},{"location":"transport/#janus_client.transport_websocket.JanusTransportWebsocket.ping","title":"ping  <code>async</code>","text":"<pre><code>ping() -&gt; Dict\n</code></pre>"},{"location":"transport/#janus_client.transport_websocket.JanusTransportWebsocket.dispatch_session_created","title":"dispatch_session_created  <code>async</code>","text":"<pre><code>dispatch_session_created(session_id: int) -&gt; None\n</code></pre> <p>Override this method to get session created event</p>"},{"location":"transport/#janus_client.transport_websocket.JanusTransportWebsocket.dispatch_session_destroyed","title":"dispatch_session_destroyed  <code>async</code>","text":"<pre><code>dispatch_session_destroyed(session_id: int) -&gt; None\n</code></pre> <p>Override this method to get session destroyed event</p>"},{"location":"transport/#janus_client.transport_websocket.JanusTransportWebsocket.connect","title":"connect  <code>async</code>","text":"<pre><code>connect() -&gt; None\n</code></pre> <p>Initialize resources</p>"},{"location":"transport/#janus_client.transport_websocket.JanusTransportWebsocket.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Release resources</p>"},{"location":"transport/#janus_client.transport_websocket.JanusTransportWebsocket.send","title":"send  <code>async</code>","text":"<pre><code>send(message: Dict, session_id: int = None, handle_id: int = None) -&gt; MessageTransaction\n</code></pre> <p>Send message to server</p> <p>:param message: JSON serializable dictionary to send</p> <p>:returns: Synchronous response from Janus server</p>"},{"location":"transport/#janus_client.transport_websocket.JanusTransportWebsocket.receive","title":"receive  <code>async</code>","text":"<pre><code>receive(response: dict) -&gt; None\n</code></pre>"},{"location":"transport/#janus_client.transport_websocket.JanusTransportWebsocket.create_session","title":"create_session  <code>async</code>","text":"<pre><code>create_session(session: JanusSession) -&gt; int\n</code></pre> <p>Create Janus Session</p>"},{"location":"transport/#janus_client.transport_websocket.JanusTransportWebsocket.destroy_session","title":"destroy_session  <code>async</code>","text":"<pre><code>destroy_session(session_id: int) -&gt; None\n</code></pre>"},{"location":"transport/#janus_client.transport_websocket.JanusTransportWebsocket.register_transport","title":"register_transport  <code>staticmethod</code>","text":"<pre><code>register_transport(protocol_matcher, transport_cls: JanusTransport) -&gt; None\n</code></pre> <p>Register transport class</p> <p>Pass in a regex matcher and it will be used to match base_url to the transport class.</p>"},{"location":"transport/#janus_client.transport_websocket.JanusTransportWebsocket.create_transport","title":"create_transport  <code>staticmethod</code>","text":"<pre><code>create_transport(base_url: str, api_secret: str = None, token: str = None, config: Dict = {}) -&gt; JanusTransport\n</code></pre> <p>Create transport class</p> <p>JanusSession will call this to create the transport class automatically using base_url parameter.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>description</p> required <code>api_secret</code> <code>str</code> <p>description. Defaults to None.</p> <code>None</code> <code>token</code> <code>str</code> <p>description. Defaults to None.</p> <code>None</code> <code>config</code> <code>Dict</code> <p>description. Defaults to {}.</p> <code>{}</code> <p>Raises:</p> Type Description <code>Exception</code> <p>No transport class found</p> <code>Exception</code> <p>More than 1 transport class found</p> <p>Returns:</p> Name Type Description <code>JanusTransport</code> <code>JanusTransport</code> <p>Use this object to communicate with Janus server.</p>"},{"location":"transport/#janus_client.transport_websocket.JanusTransportWebsocket.receive_message_done_cb","title":"receive_message_done_cb","text":"<pre><code>receive_message_done_cb(task: Task, context=None) -&gt; None\n</code></pre>"},{"location":"transport/#janus_client.transport_websocket.JanusTransportWebsocket.receive_message","title":"receive_message  <code>async</code>","text":"<pre><code>receive_message() -&gt; None\n</code></pre>"},{"location":"transport/#websocket-transport-features","title":"WebSocket Transport Features","text":"<ul> <li>Full-Duplex Communication: Real-time bidirectional messaging</li> <li>Low Latency: Direct WebSocket connection for minimal delay</li> <li>Automatic Reconnection: Handles connection drops gracefully</li> <li>Message Queuing: Buffers messages during reconnection</li> <li>Keepalive Support: Built-in ping/pong for connection health</li> </ul>"},{"location":"transport/#websocket-transport-usage","title":"WebSocket Transport Usage","text":"<pre><code>import asyncio\nfrom janus_client import JanusSession\n\nasync def main():\n    # WebSocket transport will be automatically selected for ws/wss URLs\n    session = JanusSession(base_url=\"wss://example.com/janus\")\n\n    async with session:\n        # Transport handles all WebSocket communication automatically\n        ping_response = await session.transport.ping()\n        print(f\"Ping response: {ping_response}\")\n\n        # Get server information\n        info = await session.transport.info()\n        print(f\"Server info: {info}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"transport/#transport-selection","title":"Transport Selection","text":"<p>The transport is automatically selected based on the URL scheme provided to the session:</p> URL Scheme Transport Class Description <code>http://</code> <code>JanusTransportHTTP</code> HTTP transport with long polling <code>https://</code> <code>JanusTransportHTTP</code> HTTPS transport with long polling <code>ws://</code> <code>JanusTransportWebsocket</code> WebSocket transport <code>wss://</code> <code>JanusTransportWebsocket</code> Secure WebSocket transport"},{"location":"transport/#transport-registration","title":"Transport Registration","text":"<p>Transport classes are registered using protocol matcher functions:</p> <pre><code># HTTP transport registration\ndef protocol_matcher(base_url: str) -&gt; bool:\n    return base_url.startswith((\"http://\", \"https://\"))\n\nJanusTransport.register_transport(protocol_matcher, JanusTransportHTTP)\n</code></pre>"},{"location":"transport/#custom-transport-implementation","title":"Custom Transport Implementation","text":"<p>You can create custom transport implementations by inheriting from <code>JanusTransport</code> and implementing the required abstract methods:</p> <pre><code>from janus_client import JanusTransport\nfrom typing import Dict, Any\n\nclass MyCustomTransport(JanusTransport):\n    def __init__(self, base_url: str, **kwargs):\n        super().__init__(base_url, **kwargs)\n        # Initialize custom transport-specific attributes\n        self._connection = None\n\n    async def _connect(self) -&gt; None:\n        \"\"\"Establish connection to the Janus server.\"\"\"\n        # Implement your connection logic here\n        print(f\"Connecting to {self.base_url}\")\n        # self._connection = await create_custom_connection(self.base_url)\n\n    async def _disconnect(self) -&gt; None:\n        \"\"\"Close the connection to the Janus server.\"\"\"\n        # Implement your disconnection logic here\n        if self._connection:\n            # await self._connection.close()\n            self._connection = None\n\n    async def _send(self, message: Dict[str, Any]) -&gt; None:\n        \"\"\"Send a message to the Janus server.\"\"\"\n        # Implement your message sending logic here\n        if not self._connection:\n            raise ConnectionError(\"Not connected\")\n        # await self._connection.send(message)\n\n# Protocol matcher function\ndef protocol_matcher(base_url: str) -&gt; bool:\n    \"\"\"Check if this transport can handle the URL.\"\"\"\n    return base_url.startswith(\"mycustom://\")\n\n# Register the custom transport\nJanusTransport.register_transport(protocol_matcher, MyCustomTransport)\n</code></pre>"},{"location":"transport/#transport-configuration","title":"Transport Configuration","text":"<p>Transport classes accept various configuration options through the session constructor:</p> <pre><code>session = JanusSession(\n    base_url=\"wss://example.com/janus\",\n    # Common transport options\n    timeout=30.0,           # Request timeout in seconds\n    max_retries=3,          # Maximum retry attempts\n    retry_delay=1.0,        # Initial retry delay in seconds\n    keepalive_interval=30,  # Keepalive ping interval in seconds\n\n    # HTTP-specific options\n    max_connections=10,     # Maximum HTTP connections in pool\n\n    # WebSocket-specific options\n    ping_interval=20,       # WebSocket ping interval\n    ping_timeout=10,        # WebSocket ping timeout\n)\n</code></pre>"},{"location":"transport/#error-handling-and-recovery","title":"Error Handling and Recovery","text":"<p>All transport implementations provide robust error handling:</p>"},{"location":"transport/#connection-failures","title":"Connection Failures","text":"<pre><code>import asyncio\nfrom janus_client import JanusSession\n\nasync def robust_connection():\n    session = JanusSession(\n        base_url=\"wss://example.com/janus\",\n        max_retries=5,\n        retry_delay=2.0\n    )\n\n    try:\n        async with session:\n            # Transport will automatically retry on connection failures\n            await session.transport.ping()\n    except ConnectionError as e:\n        print(f\"Failed to connect after retries: {e}\")\n    except TimeoutError as e:\n        print(f\"Connection timed out: {e}\")\n</code></pre>"},{"location":"transport/#network-timeouts","title":"Network Timeouts","text":"<pre><code>async def timeout_handling():\n    session = JanusSession(\n        base_url=\"https://example.com/janus\",\n        timeout=10.0  # 10 second timeout\n    )\n\n    try:\n        async with session:\n            # This will timeout if server doesn't respond within 10 seconds\n            info = await session.transport.info()\n    except asyncio.TimeoutError:\n        print(\"Request timed out\")\n</code></pre>"},{"location":"transport/#automatic-reconnection","title":"Automatic Reconnection","text":"<p>WebSocket transport supports automatic reconnection:</p> <pre><code>async def websocket_with_reconnection():\n    session = JanusSession(\n        base_url=\"wss://example.com/janus\",\n        max_retries=10,        # Retry up to 10 times\n        retry_delay=1.0,       # Start with 1 second delay\n        keepalive_interval=30  # Send keepalive every 30 seconds\n    )\n\n    async with session:\n        # Connection will be automatically maintained\n        # and reconnected if it drops\n        plugin = JanusEchoTestPlugin()\n        await plugin.attach(session)\n\n        # Long-running operation\n        await asyncio.sleep(300)  # 5 minutes\n\n        await plugin.destroy()\n</code></pre>"},{"location":"transport/#performance-considerations","title":"Performance Considerations","text":""},{"location":"transport/#http-vs-websocket","title":"HTTP vs WebSocket","text":"<p>Use HTTP transport when: - Simple request/response patterns - Firewall restrictions on WebSocket - Stateless operations - Lower connection overhead is acceptable</p> <p>Use WebSocket transport when: - Real-time communication is required - Low latency is important - Frequent bidirectional messaging - Long-lived connections</p>"},{"location":"transport/#connection-pooling","title":"Connection Pooling","text":"<p>HTTP transport uses connection pooling for efficiency:</p> <pre><code># Multiple sessions can share the same connection pool\nsession1 = JanusSession(base_url=\"https://example.com/janus\")\nsession2 = JanusSession(base_url=\"https://example.com/janus\")\n\n# Both sessions will reuse HTTP connections\n</code></pre>"},{"location":"transport/#resource-management","title":"Resource Management","text":"<p>Always properly close sessions to release transport resources:</p> <pre><code># Good: Using context manager\nasync with session:\n    # Transport resources are automatically cleaned up\n    pass\n\n# Also good: Manual cleanup\nsession = JanusSession(base_url=\"wss://example.com/janus\")\ntry:\n    await session.create()\n    # Use session\nfinally:\n    await session.destroy()  # Ensures transport cleanup\n</code></pre>"},{"location":"transport/#debugging-transport-issues","title":"Debugging Transport Issues","text":""},{"location":"transport/#enable-logging","title":"Enable Logging","text":"<pre><code>import logging\n\n# Enable debug logging for transport layer\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger('janus_client.transport')\nlogger.setLevel(logging.DEBUG)\n</code></pre>"},{"location":"transport/#monitor-connection-state","title":"Monitor Connection State","text":"<pre><code>async def monitor_connection():\n    session = JanusSession(base_url=\"wss://example.com/janus\")\n\n    async with session:\n        # Check if transport is connected\n        try:\n            await session.transport.ping()\n            print(\"Transport is connected and responsive\")\n        except Exception as e:\n            print(f\"Transport issue: {e}\")\n</code></pre>"},{"location":"transport/#network-analysis","title":"Network Analysis","text":"<p>For debugging network issues:</p> <ol> <li>Check server accessibility: Verify the Janus server is running and accessible</li> <li>Firewall rules: Ensure WebSocket connections are allowed</li> <li>SSL certificates: Verify HTTPS/WSS certificates are valid</li> <li>Network latency: Test network conditions between client and server</li> <li>Server logs: Check Janus server logs for connection issues</li> </ol>"},{"location":"transport/#transport-protocol-details","title":"Transport Protocol Details","text":""},{"location":"transport/#http-transport-protocol","title":"HTTP Transport Protocol","text":"<p>The HTTP transport uses the following endpoints:</p> <ul> <li><code>GET /janus/info</code> - Server information</li> <li><code>POST /janus</code> - Create session</li> <li><code>POST /janus/{session_id}</code> - Session operations</li> <li><code>GET /janus/{session_id}</code> - Long polling for messages</li> <li><code>POST /janus/{session_id}/{handle_id}</code> - Plugin operations</li> </ul>"},{"location":"transport/#websocket-transport-protocol","title":"WebSocket Transport Protocol","text":"<p>The WebSocket transport uses a single WebSocket connection for all communication:</p> <ul> <li>Connection: <code>wss://example.com/janus</code></li> <li>Protocol: <code>janus-protocol</code></li> <li>Messages: JSON-formatted Janus protocol messages</li> <li>Keepalive: Automatic ping/pong frames</li> </ul>"}]}